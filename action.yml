# =====================================================================
# XGuardian Security Scanning Action
# =====================================================================
# VersÃ£o: v25.3.0
# Autor: Xmart Solutions
#
# Esta action realiza scans de seguranÃ§a automatizados para a plataforma XGuardian.
# Suporta anÃ¡lises SAST (Source Code Analysis), SCA (Software Composition Analysis),
# e DAST (Dynamic Application Security Testing).
#
# Requisitos:
#  - Credenciais de acesso Ã  plataforma XGuardian (email/senha)
#  - Escolha de pelo menos um tipo de scan (SAST, SCA ou DAST)
#  - Para DAST: URL do site a ser analisado
#
# Para mais informaÃ§Ãµes, visite: https://github.com/marketplace/actions/xguardian-scanning
# =====================================================================

name: XGuardian Scanning
description: "Realize anÃ¡lises de seguranÃ§a automatizadas (SAST/SCA/DAST) direto do GitHub Actions para a plataforma XGuardian."
author: "Xmart Solutions"

branding:
  icon: "shield"
  color: purple
  label: Security Scanning
version: v25.3.0

inputs:
  # ========================================================================================
  # CREDENCIAIS OBRIGATÃ“RIAS
  # ========================================================================================
  api_email:
    description: "Email de acesso Ã  plataforma XGuardian. Recomenda-se usar secrets do GitHub."
    required: true
  api_password:
    description: "Senha de acesso Ã  plataforma XGuardian. Recomenda-se usar secrets do GitHub."
    required: true

  # ========================================================================================
  # CONFIGURAÃ‡ÃƒO DA APLICAÃ‡ÃƒO
  # ========================================================================================
  app_name:
    description: "Nome da aplicaÃ§Ã£o a ser escaneada. Usado para identificaÃ§Ã£o na plataforma XGuardian."
    required: true
  team_id:
    description: "ID(s) da(s) equipe(s) responsÃ¡vel(is) pela aplicaÃ§Ã£o no formato JSON. Ex: [1] ou [1,2,3]"
    default: "[1]"
    required: true
  languages:
    description: 'Linguagens de programaÃ§Ã£o da aplicaÃ§Ã£o no formato JSON array. Ex: ["JavaScript"] ou ["Java", "Python"]'
    default: '["JavaScript"]'
    required: true
  description:
    description: "DescriÃ§Ã£o da aplicaÃ§Ã£o que serÃ¡ exibida na plataforma XGuardian."
    default: "AplicaÃ§Ã£o criada atravÃ©s do GitHub Actions - XGuardian"
    required: false
  policy_sast:
    description: "ID da polÃ­tica de SAST (anÃ¡lise estÃ¡tica) a ser aplicada. Use 0 para polÃ­tica padrÃ£o."
    default: "0"
    required: false
  policy_sca:
    description: "ID da polÃ­tica de SCA (anÃ¡lise de componentes) a ser aplicada. Use 0 para polÃ­tica padrÃ£o."
    default: "0"
    required: false
  policy_dast:
    description: "ID da polÃ­tica de DAST (anÃ¡lise dinÃ¢mica) a ser aplicada. Use 0 para polÃ­tica padrÃ£o."
    default: "0"
    required: false
  microservices:
    description: "Indica se a aplicaÃ§Ã£o possui microserviÃ§os. Valores aceitos: true ou false"
    default: "false"
    required: false
  microservices_data:
    description: 'Dados dos microserviÃ§os no formato JSON array. Ex: [{"name": "MS1", "language": ["JavaScript"]}]'
    default: '[{"name": "MS1", "language": ["JavaScript"]}]'
    required: false

  # ========================================================================================
  # SELEÃ‡ÃƒO DO TIPO DE SCAN
  # ========================================================================================
  sast:
    description: "Ativa o scan SAST (anÃ¡lise estÃ¡tica de cÃ³digo fonte). Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false
  sca:
    description: "Ativa o scan SCA (anÃ¡lise de composiÃ§Ã£o de software/dependÃªncias). Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false
  dast:
    description: "Ativa o scan DAST (anÃ¡lise dinÃ¢mica de seguranÃ§a). Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false

  # ========================================================================================
  # CONFIGURAÃ‡Ã•ES PARA O SCAN DAST
  # ========================================================================================
  site_url:
    description: "URL completa do site para anÃ¡lise DAST. ObrigatÃ³rio se dast=true."
    default: ""
    required: false
    type: string
  auth_url:
    description: "URL da pÃ¡gina de autenticaÃ§Ã£o/login para o scan DAST."
    default: ""
    required: false
    type: string
  logout_url:
    description: "URL da pÃ¡gina de logout para o scan DAST."
    default: ""
    required: false
    type: string
  auth_exist:
    description: "Indica se o site requer autenticaÃ§Ã£o para o scan DAST. Valores aceitos: true ou false"
    default: false
    required: false
    type: boolean
  user_login:
    description: "Nome de usuÃ¡rio para autenticaÃ§Ã£o no site durante o scan DAST."
    default: ""
    required: false
    type: string
  password_login:
    description: "Senha para autenticaÃ§Ã£o no site durante o scan DAST. Recomenda-se usar secrets do GitHub."
    default: ""
    required: false
    type: string

  # ========================================================================================
  # CONFIGURAÃ‡Ã•ES ADICIONAIS PARA O SCAN
  # ========================================================================================
  translate:
    description: "Traduz o relatÃ³rio para portuguÃªs do Brasil. Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false
  exclude:
    description: "Lista de diretÃ³rios ou arquivos a serem excluÃ­dos do scan. Ex: 'node_modules/,dist/'"
    default: ""
    type: string
    required: false
  pdf:
    description: "Gera relatÃ³rio detalhado em PDF apÃ³s o scan. Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false
  pipeaction:
    description: "AÃ§Ã£o a executar na pipeline quando vulnerabilidades sÃ£o encontradas. Valores: warn, fail, noAction"
    default: "noAction"
    type: string
    required: false

  # ========================================================================================
  # CONFIGURAÃ‡Ã•ES DE AMBIENTE
  # ========================================================================================
  is_development:
    description: "Indica se o ambiente Ã© de desenvolvimento para usar URLs de teste. Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false

  # ========================================================================================
  # CONFIGURAÃ‡Ã•ES OPCIONAIS
  # ========================================================================================
  scan_directory:
    description: "DiretÃ³rio especÃ­fico que serÃ¡ zipado para o scan. Use '.' para analisar todo o repositÃ³rio."
    default: "."
    required: false
  get_scan_id:
    description: "Busca o ID do scan apÃ³s o upload para acompanhamento. Valores aceitos: true ou false"
    default: "false"
    type: string
    required: false
  save_vulns:
    description: "Salva as vulnerabilidades encontradas no banco de dados do XGuardian. Valores aceitos: true ou false"
    default: "false"
    required: false

outputs:
  app_id:
    description: "ID da aplicaÃ§Ã£o no XGuardian"
    value: ${{ steps.final_outputs.outputs.app_id }}
  scan_id:
    description: "ID do scan executado"
    value: ${{ steps.final_outputs.outputs.scan_id }}
  scan_url:
    description: "URL para visualizar os resultados do scan"
    value: ${{ steps.final_outputs.outputs.scan_url }}
  scan_version:
    description: "VersÃ£o do scan (baseada no app_name (nome da aplicaÃ§Ã£o) + SHA do commit)"
    value: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}

runs:
  using: "composite"
  steps:
    - name: Definir URLs do XGuardian
      id: set-urls
      shell: bash
      run: |
        if [ "${{ inputs.is_development }}" == "true" ]; then
          echo "BASE_URL"="https://shield.development.xguardianplatform.io" >> $GITHUB_ENV
          echo "UPLOADER_URL=https://uploader-mvp.development.xguardianplatform.io" >> $GITHUB_ENV
          echo "REPORTER_URL=https://reporter.development.xguardianplatform.io" >> $GITHUB_ENV
          echo "AUTH_URL=https://auth.development.xguardianplatform.io" >> $GITHUB_ENV
        else
          echo "BASE_URL"="https://shield.xguardianplatform.io" >> $GITHUB_ENV
          echo "UPLOADER_URL=https://uploader-mvp.xguardianplatform.io" >> $GITHUB_ENV
          echo "REPORTER_URL=https://reporter.xguardianplatform.io" >> $GITHUB_ENV
          echo "AUTH_URL=https://auth.xguardianplatform.io" >> $GITHUB_ENV
        fi

    - name: Verificar o ambiente antes de prosseguir
      shell: bash
      run: |
        echo "::group::ğŸ” VERIFICAÃ‡ÃƒO DO AMBIENTE"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ VERIFICANDO VARIÃVEIS DE AMBIENTE                       â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        # Lista de variÃ¡veis essenciais para verificar
        check_var() {
          local var_name="$1"
          local var_value="${!var_name}"
          
          if [ -z "$var_value" ]; then
            echo "âš ï¸ VariÃ¡vel $var_name nÃ£o definida. Isso pode causar problemas."
            return 1
          else
            echo "âœ… $var_name: OK"
            return 0
          fi
        }

        # Verificar variÃ¡veis de ambiente essenciais
        errors=0
        check_var "BASE_URL" || ((errors++))
        check_var "UPLOADER_URL" || ((errors++))
        check_var "REPORTER_URL" || ((errors++))
        check_var "AUTH_URL" || ((errors++))

        if [ $errors -gt 0 ]; then
          echo "âš ï¸ Uma ou mais variÃ¡veis de ambiente essenciais nÃ£o estÃ£o definidas."
          echo "O processo continuarÃ¡, mas poderÃ¡ encontrar erros."
        else
          echo "âœ… Todas as variÃ¡veis de ambiente essenciais estÃ£o definidas."
        fi
        echo "::endgroup::"

    - name: Validando input secrets de email e senha
      shell: bash
      env:
        API_EMAIL: ${{ inputs.api_email }}
        API_PASSWORD: ${{ inputs.api_password }}
      run: |
        echo "API_EMAIL: $API_EMAIL"
        echo "API_PASSWORD: $API_PASSWORD"

        # Validar formato de email
        if [[ ! "$API_EMAIL" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
          echo "::error::Formato de email invÃ¡lido"
          exit 1
        fi

        # Validar comprimento mÃ­nimo da senha
        PASSWORD_LENGTH=$(echo -n "$API_PASSWORD" | wc -c)
        if [ $PASSWORD_LENGTH -lt 8 ]; then
          echo "::error::Senha deve ter pelo menos 8 caracteres"
          exit 1
        fi

        echo "Todos os inputs sensÃ­veis sÃ£o vÃ¡lidos."

    - name: Validar tipos de scan
      shell: bash
      env:
        SAST: ${{ inputs.sast }}
        SCA: ${{ inputs.sca }}
        DAST: ${{ inputs.dast }}
      run: |
        if [ "${SAST}" != "true" ] && [ "${SCA}" != "true" ] && [ "${DAST}" != "true" ]; then
          echo "::error::Pelo menos um tipo de scan (SAST, SCA ou DAST) deve estar habilitado."
          exit 1
        fi

        if [ "${DAST}" == "true" ] && [ -z "${{ inputs.site_url }}" ]; then
          echo "::error::site_url Ã© obrigatÃ³rio quando o scan DAST estÃ¡ habilitado."
          exit 1
        fi

    - name: Validar e renovar token se necessÃ¡rio
      shell: bash
      env:
        AUTH_URL: ${{ env.AUTH_URL }}
        API_EMAIL: ${{ inputs.api_email }}
        API_PASSWORD: ${{ inputs.api_password }}
      run: |
        echo "::group::ValidaÃ§Ã£o de token de API"
        set -e

        renew_token() {
            echo "Renovando token..."
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
                echo "Tentativa $attempt de $max_attempts para renovar token..."
                
                response=$(curl -s --connect-timeout 10 --max-time 30 -X POST "${AUTH_URL}/login" \
                  -H 'accept: application/json' \
                  -H 'Content-Type: application/json' \
                  -d '{"email": "'${API_EMAIL}'", "password": "'${API_PASSWORD}'"}' | jq -r '.token')
                
                if [[ -n "$response" && "$response" != "null" ]]; then
                  echo "Novo token obtido com sucesso."
                  echo "API_TOKEN=$response" >> $GITHUB_ENV
                  API_TOKEN=$response
                  return 0
                fi
                
                echo "Falha na tentativa $attempt. Aguardando antes de tentar novamente..."
                sleep $(( attempt * 5 ))
                attempt=$((attempt+1))
            done
            
            echo "::error::Todas as tentativas de renovaÃ§Ã£o de token falharam."
            echo "::endgroup::"
            exit 1
        }

        echo "Verificando validade do token..."
        test_response=$(curl -s -X GET "${AUTH_URL}/ping" \
          -H 'accept: application/json' \
          -H "Authorization: Bearer ${API_TOKEN}")

        if echo "$test_response" | grep -q '"detail": "Token is invalid, Signature has expired."'; then
          renew_token
        else
          echo "Token vÃ¡lido."
        fi
        echo "::endgroup::"

    - name: Exibir informaÃ§Ãµes iniciais do processo
      shell: bash
      env:
        APP_NAME: ${{ inputs.app_name }}
        SAST: ${{ inputs.sast }}
        SCA: ${{ inputs.sca }}
        DAST: ${{ inputs.dast }}
        SITE_URL: ${{ inputs.site_url }}
        BASE_URL: ${{ env.BASE_URL }}
        REPORTER_URL: ${{ env.REPORTER_URL }}
        UPLOADER_URL: ${{ env.UPLOADER_URL }}
        AUTH_URL: ${{ env.AUTH_URL }}
        SCAN_DIR: ${{ inputs.scan_directory }}
        DEVELOPMENT: ${{ inputs.is_development }}
      run: |
        echo "::group::XGuardian Security Scan - Iniciando"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ XGuardian Security Scan - ConfiguraÃ§Ã£o Inicial          â”‚"
        echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
        echo "â”‚ AplicaÃ§Ã£o: ${APP_NAME}"
        echo "â”‚ Ambiente: $([ "${DEVELOPMENT}" == "true" ] && echo "Desenvolvimento" || echo "ProduÃ§Ã£o")"
        echo "â”‚ Tipos de scan habilitados:"
        [ "${SAST}" == "true" ] && echo "â”‚  âœ… SAST - Source Code Analysis"
        [ "${SCA}" == "true" ] && echo "â”‚  âœ… SCA - Software Composition Analysis"
        [ "${DAST}" == "true" ] && echo "â”‚  âœ… DAST - Dynamic Application Security Testing"

        if [ "${DAST}" == "true" ]; then
          echo "â”‚  ğŸ”— URL alvo DAST: ${SITE_URL}"
        fi

        echo "â”‚"
        echo "â”‚ DiretÃ³rio para scan: ${SCAN_DIR}"
        echo "â”‚"
        echo "â”‚ URLs XGuardian:"
        echo "â”‚  ğŸ”— Base: ${BASE_URL}"
        echo "â”‚  ğŸ”— Uploader: ${UPLOADER_URL}"
        echo "â”‚  ğŸ”— Reporter: ${REPORTER_URL}"
        echo "â”‚  ğŸ”— Auth: ${AUTH_URL}"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        echo "::endgroup::"

        # Criar log com hora de inÃ­cio para cÃ¡lculo de duraÃ§Ã£o total
        echo "$(date +%s)" > /tmp/xguardian_start_time

    - name: Instalar dependÃªncias
      shell: bash
      run: |
        echo "::group::InstalaÃ§Ã£o de dependÃªncias"
        echo "ğŸ“¦ Atualizando pacotes do sistema..."
        sudo apt-get update -qq > /dev/null

        echo "ğŸ“¥ Instalando ferramentas necessÃ¡rias (curl, jq, zip)..."
        sudo apt-get install -y --no-install-recommends curl jq zip > /dev/null

        echo "âœ… DependÃªncias bÃ¡sicas instaladas com sucesso!"
        echo "::endgroup::"

    - name: Fazer login na API e armazenar o token
      shell: bash
      env:
        AUTH_URL: ${{ env.AUTH_URL }}
        API_EMAIL: ${{ inputs.api_email }}
        API_PASSWORD: ${{ inputs.api_password }}
      run: |
        echo "::group::ğŸ” AUTENTICAÃ‡ÃƒO NA API XGUARDIAN"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ INICIANDO PROCESSO DE AUTENTICAÃ‡ÃƒO                      â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        # FunÃ§Ã£o para tratamento de erros
        handle_error() {
          local error_msg="$1"
          local exit_code="${2:-1}"
          
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ âŒ ERRO: $error_msg                                     â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::error::$error_msg"
          echo "::endgroup::"
          exit "$exit_code"
        }

        # FunÃ§Ã£o para fazer login com retry
        login_with_retry() {
          local max_attempts=3
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "ğŸ”„ Tentativa $attempt de $max_attempts para obter token..."
            
            response=$(curl -s -X 'POST' "${AUTH_URL}/login" \
              -H 'accept: application/json' \
              -H 'Content-Type: application/json' \
              -d '{
                "email": "'"${API_EMAIL}"'",
                "password": "'"${API_PASSWORD}"'"
              }' | jq -r '.token')
              
            if [ -n "$response" ] && [ "$response" != "null" ]; then
              echo "API_TOKEN=$response" >> $GITHUB_ENV
              echo "âœ… Token obtido com sucesso!"
              return 0
            fi
            
            echo "âš ï¸ Falha na tentativa $attempt. Aguardando antes de tentar novamente..."
            sleep $(( attempt * 5 ))
            attempt=$((attempt+1))
          done
          
          handle_error "Todas as tentativas de login falharam. Verifique suas credenciais ou a disponibilidade da API."
        }

        login_with_retry
        echo "::endgroup::"

    - name: Verificar se a aplicaÃ§Ã£o existe, caso contrÃ¡rio, cria a aplicaÃ§Ã£o
      shell: bash
      env:
        UPLOADER_URL: ${{ env.UPLOADER_URL }}
        APP_NAME: ${{ inputs.app_name }}
        API_TOKEN: ${{ env.API_TOKEN }}
        TEAM_ID: ${{ inputs.team_id }}
        LANGUAGES: ${{ inputs.languages }}
        DESCRIPTION: ${{ inputs.description }}
        POLICY_SAST: ${{ inputs.policy_sast }}
        POLICY_SCA: ${{ inputs.policy_sca }}
        POLICY_DAST: ${{ inputs.policy_dast }}
        MICROSERVICES: ${{ inputs.microservices }}
        MICROSERVICES_DATA: ${{ inputs.microservices_data }}
      run: |
        echo "::group::Verificando e configurando aplicaÃ§Ã£o"
        # Converte caracteres especiais para espaÃ§os, mantendo espaÃ§os existentes
        CLEAN_APP_NAME=$(echo "${APP_NAME}" | tr -c '[:alnum:] ' ' ')

        # AlteraÃ§Ã£o para `create_apps` por conta da remoÃ§Ã£o de polÃ­ticas do payload
        # "${UPLOADER_URL}/docs#/apps/create_app_create_apps_post"
        CREATE_APP_URL="${UPLOADER_URL}/create_apps"

        # Verificar se a aplicaÃ§Ã£o jÃ¡ existe
        EXISTING_APP=$(curl -sS -X GET \
          "${UPLOADER_URL}/get_apps_new?page=1&items_per_page=10" \
          -H 'accept: application/json' \
          -H "Authorization: Bearer ${API_TOKEN}")

        # Verifica se a resposta Ã© um JSON vÃ¡lido
        if ! echo "$EXISTING_APP" | jq . >/dev/null 2>&1; then
          echo "::error::Resposta da API nÃ£o Ã© um JSON vÃ¡lido: $EXISTING_APP"
          exit 1
        fi

        # Buscar o APP_ID da aplicaÃ§Ã£o existente mais recente com o mesmo nome
        APP_ID=$(echo "$EXISTING_APP" | jq -r --arg NAME "$APP_NAME" '.data[] | select(.name == $NAME) | .id' | head -n 1)

        if [ -n "$APP_ID" ]; then
          echo "APP_ID encontrado: $APP_ID para a aplicaÃ§Ã£o: $APP_NAME"
          
          # Verificar se o comando jq funciona corretamente com a resposta
          if ! echo "$EXISTING_APP" | jq . > /dev/null 2>&1; then
            echo "::warning::Resposta da API contÃ©m JSON malformado. Usando valores padrÃ£o para polÃ­ticas."
            echo "APP_ID=$APP_ID" >> $GITHUB_ENV
            echo "POLICY_SAST=0" >> $GITHUB_ENV
            echo "POLICY_SCA=0" >> $GITHUB_ENV
            echo "POLICY_DAST=0" >> $GITHUB_ENV
            echo "PolÃ­ticas definidas: SAST=0, SCA=0, DAST=0 (valores padrÃ£o)"
          else
            # ObtÃ©m os detalhes apenas da primeira aplicaÃ§Ã£o encontrada (a mais recente)
            APP_DETAILS=$(echo "$EXISTING_APP" | jq --arg NAME "$APP_NAME" --arg ID "$APP_ID" '.data[] | select(.name == $NAME and .id == ($ID | tonumber))' | head -n 1)
            
            # Verifica se APP_DETAILS Ã© vÃ¡lido antes de continuar
            if [ -z "$APP_DETAILS" ] || ! echo "$APP_DETAILS" | jq . > /dev/null 2>&1; then
              echo "::warning::Detalhes da aplicaÃ§Ã£o contÃªm JSON malformado. Usando valores padrÃ£o para polÃ­ticas."
              echo "APP_ID=$APP_ID" >> $GITHUB_ENV
              echo "POLICY_SAST=0" >> $GITHUB_ENV
              echo "POLICY_SCA=0" >> $GITHUB_ENV
              echo "POLICY_DAST=0" >> $GITHUB_ENV
              echo "PolÃ­ticas definidas: SAST=0, SCA=0, DAST=0 (valores padrÃ£o)"
            else
              echo "Detalhes da aplicaÃ§Ã£o:"
              echo "$APP_DETAILS" | jq .
              echo "APP_ID=$APP_ID" >> $GITHUB_ENV
              
              # Extrai os valores das polÃ­ticas apenas da aplicaÃ§Ã£o selecionada
              POLICY_SAST=$(echo "$APP_DETAILS" | jq -r '.policies_id_sast // "0"')
              POLICY_SCA=$(echo "$APP_DETAILS" | jq -r '.policies_id_sca // "0"')
              POLICY_DAST=$(echo "$APP_DETAILS" | jq -r '.policies_id_dast // "0"')
              
              # Verifica e garante valores padrÃ£o para polÃ­ticas nulas ou vazias
              POLICY_SAST_SAFE=$([ -n "$POLICY_SAST" ] && [ "$POLICY_SAST" != "null" ] && echo "$POLICY_SAST" || echo "0")
              POLICY_SCA_SAFE=$([ -n "$POLICY_SCA" ] && [ "$POLICY_SCA" != "null" ] && echo "$POLICY_SCA" || echo "0")
              POLICY_DAST_SAFE=$([ -n "$POLICY_DAST" ] && [ "$POLICY_DAST" != "null" ] && echo "$POLICY_DAST" || echo "0")
              
              # Definir as variÃ¡veis de ambiente com os valores seguros
              echo "POLICY_SAST=$POLICY_SAST_SAFE" >> $GITHUB_ENV
              echo "POLICY_SCA=$POLICY_SCA_SAFE" >> $GITHUB_ENV
              echo "POLICY_DAST=$POLICY_DAST_SAFE" >> $GITHUB_ENV
              
              # Log para debug
              echo "PolÃ­ticas definidas: SAST=$POLICY_SAST_SAFE, SCA=$POLICY_SCA_SAFE, DAST=$POLICY_DAST_SAFE"
            fi
          fi
        else
          echo "A aplicaÃ§Ã£o nÃ£o existe. Criando nova aplicaÃ§Ã£o..."

          # Verificar se a equipe existe antes de tentar criar a aplicaÃ§Ã£o
          echo "Verificando se a equipe $TEAM_ID existe..."
          TEAMS_RESPONSE=$(curl -sS -X GET \
            "${UPLOADER_URL}/get_teams?page=1&items_per_page=100" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")
          
          # Extrai IDs das equipes disponÃ­veis para comparar
          if echo "$TEAMS_RESPONSE" | jq -e '.data' > /dev/null 2>&1; then
            # Extrair todos os IDs de equipe disponÃ­veis
            AVAILABLE_TEAM_IDS=$(echo "$TEAMS_RESPONSE" | jq -r '.data[].id')
            
            # Extrair IDs fornecidos pelo usuÃ¡rio (removendo colchetes e espaÃ§os)
            USER_TEAM_IDS=$(echo "$TEAM_ID" | tr -d '[]" ' | tr ',' '\n')
            
            # Flag para verificar se todas as equipes existem
            ALL_TEAMS_EXIST=true
            INVALID_TEAMS=""
            
            # Verificar cada ID fornecido pelo usuÃ¡rio
            for team_id in $USER_TEAM_IDS; do
              if ! echo "$AVAILABLE_TEAM_IDS" | grep -q "^$team_id$"; then
                ALL_TEAMS_EXIST=false
                INVALID_TEAMS="$INVALID_TEAMS $team_id"
              fi
            done
            
            if [ "$ALL_TEAMS_EXIST" = false ]; then
              echo "::error::Equipe(s)${INVALID_TEAMS} nÃ£o encontrada(s) ou nÃ£o pertence(m) Ã  sua organizaÃ§Ã£o."
              echo "::error::Por favor, verifique o ID da equipe fornecido em 'team_id' e tente novamente."
              echo "::error::Equipes disponÃ­veis para sua conta:"
              echo "$TEAMS_RESPONSE" | jq -r '.data[] | "ID: \(.id) - Nome: \(.name)"'
              echo "::endgroup::"
              exit 1
            else
              echo "âœ… Equipe(s) verificada(s) com sucesso!"
            fi
          else
            echo "::warning::NÃ£o foi possÃ­vel verificar as equipes disponÃ­veis. Continuando mesmo assim..."
          fi

          # Determine microservices value
          if [[ "${MICROSERVICES}" == "true" ]]; then
            MICROSERVICES_VALUE="true"
          else
            MICROSERVICES_VALUE="false"
          fi
          
          # Start building the JSON
          JSON_CONTENT='{'
          JSON_CONTENT+='"app_name": "'"${APP_NAME}"'",'
          JSON_CONTENT+='"team_id": '"${TEAM_ID}"','
          JSON_CONTENT+='"languages": '"${LANGUAGES}"','
          JSON_CONTENT+='"description": "'"${DESCRIPTION}"'",'
          JSON_CONTENT+='"microservices": '"${MICROSERVICES_VALUE}"
          
          # Add microservices_data only if microservices is true
          if [[ "${MICROSERVICES}" == "true" ]]; then
            JSON_CONTENT+=',"microservices_data": '"${MICROSERVICES_DATA}"
          fi
          
          JSON_CONTENT+='}'
          
          echo "ğŸ“ Payload para criaÃ§Ã£o da aplicaÃ§Ã£o:"
          echo "$JSON_CONTENT" | jq .
          
          RESPONSE=$(curl -sS -X POST "${CREATE_APP_URL}" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H 'Content-Type: application/json' \
            -d "${JSON_CONTENT}")

          echo "ğŸ“„ Resposta da API:"
          echo "$RESPONSE" | jq . || echo "$RESPONSE"

          # Verificar se a resposta contÃ©m a mensagem de sucesso
          if echo "$RESPONSE" | grep -q '"sucess":"AplicaÃ§Ã£o\|"success":"AplicaÃ§Ã£o'; then
            echo "âœ… AplicaÃ§Ã£o criada com sucesso."
            echo "APP_ID=N/A" >> $GITHUB_ENV
          else
            # Melhor tratamento de erro com mensagem especÃ­fica
            if echo "$RESPONSE" | grep -q "Equipe"; then
              ERROR_MSG=$(echo "$RESPONSE" | jq -r '.Equipe // "Erro desconhecido com a equipe"')
              echo "::error::Erro ao criar aplicaÃ§Ã£o: $ERROR_MSG"
              echo "::error::Verifique se o ID da equipe fornecido em 'team_id' estÃ¡ correto."
              echo "::error::O valor atual Ã©: $TEAM_ID"
            else
              echo "::error::Erro inesperado na criaÃ§Ã£o da aplicaÃ§Ã£o:"
              echo "$RESPONSE" | jq . || echo "$RESPONSE"
            fi
            echo "::endgroup::"
            exit 1
          fi
        fi
        echo "::endgroup::"

    - name: Verificar polÃ­ticas definidas
      shell: bash
      env:
        AUTH_URL: ${{ env.AUTH_URL }}
        API_TOKEN: ${{ env.API_TOKEN }}
        POLICY_SAST: "${{ env.POLICY_SAST }}"
        POLICY_SCA: "${{ env.POLICY_SCA }}"
        POLICY_DAST: "${{ env.POLICY_DAST }}"
      run: |
        echo "::group::VerificaÃ§Ã£o de polÃ­ticas aplicadas"
        # Verificar se todas as polÃ­ticas sÃ£o 0 ou nÃ£o definidas
        if [[ "${POLICY_SAST}" == "0" && "${POLICY_SCA}" == "0" && "${POLICY_DAST}" == "0" ]]; then
          echo "Nenhuma polÃ­tica definida (todos os valores sÃ£o 0). Pulando verificaÃ§Ã£o de polÃ­ticas."
          echo "::endgroup::"
          exit 0
        fi

        check_policies() {
          local scan_type=$1
          local app_policy_id=$2

          echo "::group::VerificaÃ§Ã£o de polÃ­ticas para ${scan_type^^}"
          
          # Pula a verificaÃ§Ã£o se a polÃ­tica for 0 ou nÃ£o definida
          if [[ -z "$app_policy_id" || "$app_policy_id" == "0" || "$app_policy_id" == "null" ]]; then
            echo "PolÃ­tica para ${scan_type} nÃ£o definida ou com valor 0. Pulando verificaÃ§Ã£o."
            echo "::endgroup::"
            return 0
          fi

          echo "Verificando polÃ­tica para ${scan_type} com ID ${app_policy_id}..."
          
          local response=$(curl -s -X GET "${AUTH_URL}/get_policies_${scan_type}" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")

          # Verifica se a resposta Ã© um JSON vÃ¡lido
          if ! echo "$response" | jq '.' > /dev/null 2>&1; then
            echo "::error::Resposta da API nÃ£o Ã© um JSON vÃ¡lido: $response"
            echo "::endgroup::"
            return 1
          fi

          # Exibe todas as polÃ­ticas disponÃ­veis (para debug)
          echo "PolÃ­ticas disponÃ­veis para ${scan_type}:"
          echo "$response" | jq '.'

          # Busca a polÃ­tica especÃ­fica
          local policy=$(echo "$response" | jq --arg id "$app_policy_id" '.[] | select(.id == ($id | tonumber))')
          
          # Verifica se a polÃ­tica foi encontrada
          if [ -z "$policy" ] || [ "$policy" == "null" ]; then
            echo "::warning::PolÃ­tica atribuÃ­da para ${scan_type} com ID ${app_policy_id} nÃ£o encontrada nas polÃ­ticas disponÃ­veis."
            echo "::warning::Usando polÃ­tica padrÃ£o com valores 0 para todos os nÃ­veis."
            # Define valores padrÃ£o caso a polÃ­tica nÃ£o seja encontrada
            echo "${scan_type^^}_CRITICAL=0" >> $GITHUB_ENV
            echo "${scan_type^^}_HIGH=0" >> $GITHUB_ENV
            echo "${scan_type^^}_MEDIUM=0" >> $GITHUB_ENV
            echo "${scan_type^^}_LOW=0" >> $GITHUB_ENV
            echo "${scan_type^^}_RATING=0" >> $GITHUB_ENV
            echo "${scan_type^^}_PIPEACTION=noAction" >> $GITHUB_ENV
            echo "::endgroup::"
            return 0
          fi

          # Exibe os detalhes da polÃ­tica
          echo "PolÃ­tica encontrada para ${scan_type}:"
          echo "$policy" | jq '.'

          # Extrai os valores da polÃ­tica
          export CRITICAL=$(echo "$policy" | jq -r '.critical')
          export HIGH=$(echo "$policy" | jq -r '.high')
          export MEDIUM=$(echo "$policy" | jq -r '.medium')
          export LOW=$(echo "$policy" | jq -r '.low')
          export RATING=$(echo "$policy" | jq -r '.rating')
          export PIPEACTION=$(echo "$policy" | jq -r '.pipeaction')

          # Verifica se os valores foram extraÃ­dos corretamente
          if [ -z "$CRITICAL" ] || [ -z "$HIGH" ] || [ -z "$MEDIUM" ] || [ -z "$LOW" ] || [ -z "$RATING" ] || [ -z "$PIPEACTION" ]; then
            echo "::warning::Falha ao extrair valores da polÃ­tica para ${scan_type}. Usando valores padrÃ£o."
            CRITICAL=0
            HIGH=0
            MEDIUM=0
            LOW=0
            RATING=0
            PIPEACTION="noAction"
          fi

          # Define as variÃ¡veis de ambiente
          echo "${scan_type^^}_CRITICAL=$CRITICAL" >> $GITHUB_ENV
          echo "${scan_type^^}_HIGH=$HIGH" >> $GITHUB_ENV
          echo "${scan_type^^}_MEDIUM=$MEDIUM" >> $GITHUB_ENV
          echo "${scan_type^^}_LOW=$LOW" >> $GITHUB_ENV
          echo "${scan_type^^}_RATING=$RATING" >> $GITHUB_ENV
          echo "${scan_type^^}_PIPEACTION=$PIPEACTION" >> $GITHUB_ENV

          echo "PolÃ­tica para ${scan_type^^} configurada com sucesso:"
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ Limites de vulnerabilidades para ${scan_type^^} â”‚"
          echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
          echo "â”‚ CRITICAL: $CRITICAL                          "
          echo "â”‚ HIGH:     $HIGH                              "
          echo "â”‚ MEDIUM:   $MEDIUM                            "
          echo "â”‚ LOW:      $LOW                               "
          echo "â”‚ RATING:   $RATING                            "
          echo "â”‚ AÃ‡ÃƒO:     $PIPEACTION                        "
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::endgroup::"
        }

        # Realiza as verificaÃ§Ãµes individuais para cada tipo de scan
        check_policies "sast" "${POLICY_SAST}" || echo "::warning::Falha ao verificar polÃ­tica SAST."
        check_policies "sca" "${POLICY_SCA}" || echo "::warning::Falha ao verificar polÃ­tica SCA."
        check_policies "dast" "${POLICY_DAST}" || echo "::warning::Falha ao verificar polÃ­tica DAST."

        echo "VerificaÃ§Ã£o de polÃ­ticas concluÃ­da."
        echo "::endgroup::"

    - name: Buscar polÃ­ticas apÃ³s criaÃ§Ã£o da aplicaÃ§Ã£o
      shell: bash
      env:
        AUTH_URL: ${{ env.AUTH_URL }}
        API_TOKEN: ${{ env.API_TOKEN }}
        APP_ID: ${{ env.APP_ID }}
      run: |
        echo "::group::ğŸ“‹ POLÃTICAS DISPONÃVEIS NA PLATAFORMA"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ POLÃTICAS DE SEGURANÃ‡A DISPONÃVEIS                      â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        echo "Buscando polÃ­ticas disponÃ­veis para cada tipo de scan..."

        fetch_policies() {
          local scan_type=$1
          echo "::group::ğŸ“œ PolÃ­ticas disponÃ­veis para ${scan_type^^}"
          
          local response=$(curl -s -X GET "${AUTH_URL}/get_policies_${scan_type}" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")

          if ! echo "$response" | jq '.' > /dev/null 2>&1; then
            echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
            echo "â”‚ âŒ ERRO: RESPOSTA DA API INVÃLIDA                       â”‚"
            echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
            echo "::error::Resposta da API nÃ£o Ã© um JSON vÃ¡lido: $response"
            echo "::endgroup::"
            return 1
          fi

          # Mostrar o nÃºmero total de polÃ­ticas encontradas
          local total_policies=$(echo "$response" | jq '. | length')
          echo "Total de polÃ­ticas para ${scan_type^^}: $total_policies"
          
          # Filtra polÃ­ticas que nÃ£o sejam default
          local custom_policies=$(echo "$response" | jq -r '
            [.[] | select(.name and .description) | 
            select((.name | ascii_downcase) != "default" and (.description | ascii_downcase) != "default")]')
          
          local custom_count=$(echo "$custom_policies" | jq '. | length')
          echo "PolÃ­ticas personalizadas para ${scan_type^^}: $custom_count"

          if [ "$custom_count" -gt 0 ]; then
            # Tabela formatada com caracteres de borda para melhor leitura
            echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
            echo "â”‚   ID  â”‚       NOME         â”‚        AÃ‡ÃƒO        â”‚"
            echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
            
            echo "$custom_policies" | jq -r '.[] | "â”‚ \(.id) â”‚ \(.name) â”‚ \(.pipeaction) â”‚"'
            
            echo "â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
            
            # Para informaÃ§Ãµes mais detalhadas, mostrar cada polÃ­tica de forma organizada
            echo "ğŸ“Š Detalhes das polÃ­ticas (expandir para ver):"
            echo "$custom_policies" | jq -r '.[] | "ID: \(.id) - \(.name)\n  â€¢ CrÃ­tico: \(.critical)\n  â€¢ Alto: \(.high)\n  â€¢ MÃ©dio: \(.medium)\n  â€¢ Baixo: \(.low)\n  â€¢ AÃ§Ã£o: \(.pipeaction)\n"'
          else
            echo "â„¹ï¸ Nenhuma polÃ­tica personalizada encontrada para ${scan_type^^}."
          fi
          echo "::endgroup::"
        }

        fetch_policies "sast" || echo "::warning::Falha ao buscar polÃ­ticas SAST."
        fetch_policies "sca" || echo "::warning::Falha ao buscar polÃ­ticas SCA."
        fetch_policies "dast" || echo "::warning::Falha ao buscar polÃ­ticas DAST."

        echo "âœ… Busca de polÃ­ticas concluÃ­da."
        echo "::endgroup::"

    - name: Obter o short_sha
      id: vars
      shell: bash
      env:
        GITHUB_SHA: ${{ github.sha }}
      run: |
        echo "short_sha=${GITHUB_SHA:0:6}" >> $GITHUB_OUTPUT

    - name: Verificar prÃ©-requisitos antes da anÃ¡lise
      if: ${{ inputs.sast == 'true' || inputs.sca == 'true' }}
      shell: bash
      env:
        APP_ID: ${{ env.APP_ID }}
        API_TOKEN: ${{ env.API_TOKEN }}
      run: |
        echo "::group::ğŸ” VERIFICAÃ‡ÃƒO DE PRÃ‰-REQUISITOS"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ VERIFICANDO PRÃ‰-REQUISITOS PARA SCAN                    â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        # Verificar se temos um token vÃ¡lido
        if [ -z "$API_TOKEN" ]; then
          echo "::error::Token de API nÃ£o encontrado. Verifique se a autenticaÃ§Ã£o foi realizada corretamente."
          echo "::endgroup::"
          exit 1
        fi

        # Verificar se temos um ID de aplicaÃ§Ã£o
        if [ -z "$APP_ID" ] || [ "$APP_ID" = "N/A" ]; then
          echo "::warning::ID da aplicaÃ§Ã£o indefinido ou marcado como N/A. A etapa seguinte tentarÃ¡ buscar o ID correto."
        else
          echo "âœ… ID da aplicaÃ§Ã£o configurado: $APP_ID"
        fi

        echo "âœ… Todos os prÃ©-requisitos verificados!"
        echo "::endgroup::"

    - name: Criar o Scan SAST e/ou SCA (Obter URL de upload)
      if: ${{ inputs.sast == 'true' || inputs.sca == 'true' }}
      shell: bash
      env:
        UPLOADER_URL: ${{ env.UPLOADER_URL }}
        APP_ID: ${{ env.APP_ID }}
        SAST: ${{ inputs.sast }}
        SCA: ${{ inputs.sca }}
        TRANSLATE: ${{ inputs.translate }}
        EXCLUDE: ${{ inputs.exclude }}
        PDF: ${{ inputs.pdf }}
        SCAN_VERSION: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}
        API_TOKEN: ${{ env.API_TOKEN }}
      run: |
        echo "::group::Preparando scan SAST/SCA"
        echo "ğŸ“‹ Configurando scan com as seguintes opÃ§Ãµes:"
        echo "  â€¢ APP_ID: ${APP_ID}"
        echo "  â€¢ SCAN_VERSION: ${SCAN_VERSION}"
        echo "  â€¢ SAST: ${SAST}"
        echo "  â€¢ SCA: ${SCA}"
        echo "  â€¢ TRANSLATE: ${TRANSLATE}"
        echo "  â€¢ PDF: ${PDF}"

        # Verificar se o APP_ID Ã© N/A e buscar o ID correto
        if [ "${APP_ID}" = "N/A" ]; then
          echo "ğŸ” APP_ID Ã© N/A, buscando o ID correto..."
          RESPONSE=$(curl -sS -X GET "${UPLOADER_URL}/get_apps_new?page=1&items_per_page=10" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")

          echo "::group::Resposta detalhada da API (debug)"
          echo "$RESPONSE"
          echo "::endgroup::"

          APP_ID=$(echo "$RESPONSE" | jq -r --arg NAME "${{ inputs.app_name }}" '.data[] | select(.name == $NAME) | .id' | head -n 1)

          if [ -z "$APP_ID" ]; then
            echo "âŒ NÃ£o foi possÃ­vel encontrar o APP_ID para a aplicaÃ§Ã£o ${inputs.app_name}"
            echo "::error::NÃ£o foi possÃ­vel encontrar o APP_ID para a aplicaÃ§Ã£o ${{ inputs.app_name }}"
            echo "::endgroup::"
            exit 1
          fi

          echo "âœ… APP_ID encontrado: $APP_ID"
          echo "APP_ID=$APP_ID" >> $GITHUB_ENV
        fi

        UPLOAD_URL="${UPLOADER_URL}/upload-url"

        DATA=$(cat << EOF
        {
          "app_id": ${APP_ID},
          "scan_version": "${SCAN_VERSION}",
          "file_type": "application/zip",
          "sca": "${SCA}",
          "sast": "${SAST}",
          "translate": "${TRANSLATE}", 
          "exclude": "${EXCLUDE}",
          "pdf": "${PDF}"
        }
        EOF
        )

        echo "::group::Payload da requisiÃ§Ã£o (para debug)"
        echo "$DATA" | jq '.' || echo "$DATA"
        echo "::endgroup::"

        echo "ğŸš€ Enviando solicitaÃ§Ã£o para obter URL de upload..."

        RESPONSE=$(curl -sS -X POST "${UPLOAD_URL}" \
            -H 'accept: application/json' \
            -H 'Content-Type: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -d "${DATA}")

        echo "::group::Resposta completa da API (para debug)"
        echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
        echo "::endgroup::"

        GET_UPLOAD_URL=$(echo "${RESPONSE}" | jq -r '.url')

        if [ -z "$GET_UPLOAD_URL" ] || [ "$GET_UPLOAD_URL" = "null" ]; then
          echo "âŒ Erro: NÃ£o foi possÃ­vel obter a URL de upload"
          echo "::error::NÃ£o foi possÃ­vel obter a URL de upload. Verifique a resposta da API."
          echo "::endgroup::"
          exit 1
        fi

        echo "âœ… URL de upload obtida com sucesso"
        # Mostrar apenas parte inicial da URL para evitar poluir o log
        URL_PREVIEW=$(echo "${GET_UPLOAD_URL}" | cut -c 1-90)
        echo "ğŸ”— URL de Upload: ${URL_PREVIEW}..."
        echo "GET_UPLOAD_URL=${GET_UPLOAD_URL}" >> $GITHUB_ENV
        echo "::endgroup::"

    - name: Realizar o scan DAST
      if: ${{ inputs.dast == 'true' }}
      shell: bash
      env:
        UPLOADER_URL: ${{ env.UPLOADER_URL }}
        API_TOKEN: ${{ env.API_TOKEN }}
        APP_ID: ${{ env.APP_ID }}
        SCAN_VERSION: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}
        SITE_URL: ${{ inputs.site_url }}
        AUTH_URL: ${{ inputs.auth_url }}
        LOGOUT_URL: ${{ inputs.logout_url }}
        AUTH_EXIST: ${{ inputs.auth_exist }}
        USER_LOGIN: ${{ inputs.user_login }}
        PASSWORD: ${{ inputs.password_login }}
        TRANSLATE: ${{ inputs.translate }}
        PDF: ${{ inputs.pdf }}
      run: |
        echo "::group::ConfiguraÃ§Ã£o e execuÃ§Ã£o do scan DAST"
        echo "ğŸ” Preparando scan DAST para ${SITE_URL}..."
        UPLOAD_DAST_URL="${UPLOADER_URL}/upload-dast"

        # Verificar se o APP_ID Ã© N/A e buscar o ID correto se necessÃ¡rio
        if [ "${APP_ID}" = "N/A" ]; then
          echo "âš ï¸ APP_ID Ã© N/A, buscando o ID correto..."
          
          echo "::group::RequisiÃ§Ã£o para obter APP_ID"
          RESPONSE=$(curl -sS -X GET "${UPLOADER_URL}/get_apps_new?page=1&items_per_page=10" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")
          
          # Debug controlado - sÃ³ mostrar se necessÃ¡rio
          if [ $? -ne 0 ]; then
            echo "âŒ Falha na requisiÃ§Ã£o HTTP para obter APP_ID"
            echo "Resposta completa:"
            echo "$RESPONSE"
            echo "::endgroup::"
            echo "::error::Falha ao buscar dados da aplicaÃ§Ã£o. Verifique a conexÃ£o e o servidor."
            echo "::endgroup::"
            exit 1
          fi
          echo "::endgroup::"

          APP_ID=$(echo "$RESPONSE" | jq -r --arg NAME "${{ inputs.app_name }}" '.data[] | select(.name == $NAME) | .id' | head -n 1)

          if [ -z "$APP_ID" ]; then
            echo "::error::âŒ NÃ£o foi possÃ­vel encontrar o APP_ID para a aplicaÃ§Ã£o ${inputs.app_name}"
            echo "::group::Resposta da API (debug)"
            echo "$RESPONSE" | jq -r '.' || echo "$RESPONSE"
            echo "::endgroup::"
            echo "::endgroup::"
            exit 1
          fi

          echo "âœ… APP_ID encontrado: $APP_ID"
          echo "APP_ID=$APP_ID" >> $GITHUB_ENV
        fi

        # Construindo o payload para o scan DAST
        echo "ğŸ“ Configurando parÃ¢metros do scan DAST:"
        echo "  â€¢ APP_ID: ${APP_ID}"
        echo "  â€¢ SCAN_VERSION: ${SCAN_VERSION}"
        echo "  â€¢ SITE_URL: ${SITE_URL}"
        [ -n "${AUTH_URL}" ] && echo "  â€¢ URL de autenticaÃ§Ã£o: ${AUTH_URL}"
        [ -n "${LOGOUT_URL}" ] && echo "  â€¢ URL de logout: ${LOGOUT_URL}"
        echo "  â€¢ AutenticaÃ§Ã£o necessÃ¡ria: ${AUTH_EXIST}"
        [ "${AUTH_EXIST}" = "true" ] && echo "  â€¢ UsuÃ¡rio: ${USER_LOGIN}"
        echo "  â€¢ TraduÃ§Ã£o ativada: ${TRANSLATE}"
        echo "  â€¢ PDF ativado: ${PDF}"

        DATA=$(cat << EOF
        {
          "app_id": "${APP_ID}",
          "scan_version_dast": "${SCAN_VERSION}",
          "site_url": "${SITE_URL}",
          "auth_url": "${AUTH_URL}",
          "logout_url": "${LOGOUT_URL}",
          "authexist": ${AUTH_EXIST},
          "userlogin": "${USER_LOGIN}",
          "passwordlogin": "${PASSWORD}",
          "translate": "${TRANSLATE}",
          "pdf": "${PDF}"
        }
        EOF
        )

        echo "::group::Payload da requisiÃ§Ã£o DAST (para debug)"
        # Mascarando a senha no log
        echo "$DATA" | jq '. + {"passwordlogin": "********"}' || echo "$DATA" | sed 's/"passwordlogin":"[^"]*"/"passwordlogin":"********"/g'
        echo "::endgroup::"

        echo "ğŸš€ Iniciando scan DAST..."
        echo "::group::Resposta da API (completa)"
        RESPONSE=$(curl -sS -X POST "${UPLOAD_DAST_URL}" \
          -H 'accept: application/json' \
          -H "Authorization: Bearer ${API_TOKEN}" \
          -H 'Content-Type: application/json' \
          -d "${DATA}")

        # Exibir a resposta apenas no grupo
        echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
        echo "::endgroup::"

        # Verificar se o token expirou e renovar se necessÃ¡rio
        if echo "$RESPONSE" | grep -q '"detail": "Token is invalid, Signature has expired."'; then
          echo "âš ï¸ Token expirado, renovando..."
          renew_token
          
          echo "ğŸ”„ Reenviar solicitaÃ§Ã£o com novo token..."
          echo "::group::Nova resposta da API"
          RESPONSE=$(curl -sS -X POST "${UPLOAD_DAST_URL}" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}" \
            -H 'Content-Type: application/json' \
            -d "${DATA}")
          echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
          echo "::endgroup::"
        fi

        # Verificar resposta e processar adequadamente
        if echo "$RESPONSE" | grep -q '"scan_id"'; then
          SCAN_ID=$(echo "$RESPONSE" | jq -r '.scan_id')
          echo "âœ… Scan DAST iniciado com sucesso!"
          echo "ğŸ“Š ID do scan DAST: ${SCAN_ID}"
          echo "SCAN_ID=${SCAN_ID}" >> $GITHUB_ENV
          echo "::notice title=XGuardian Scan DAST::Scan DAST iniciado com sucesso para ${SITE_URL}"
        else
          echo "âš ï¸ Problema na resposta do servidor:"
          if echo "$RESPONSE" | grep -q 'error\|fail\|invalid'; then
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error // .message // .detail // "Erro desconhecido"')
            echo "âŒ Falha detectada: ${ERROR_MSG}"
            echo "::error title=XGuardian Scan DAST::Falha ao iniciar scan DAST: ${ERROR_MSG}"
          else
            echo "âš ï¸ Resposta sem formato esperado:"
            echo "$RESPONSE" | jq -r '.'
            echo "::warning title=XGuardian Scan DAST::Resposta nÃ£o contÃ©m scan_id. Verifique a resposta da API."
          fi
        fi
        echo "::endgroup::"

    - name: Zipar os arquivos
      if: ${{ inputs.sast == 'true' || inputs.sca == 'true' }}
      shell: bash
      env:
        APP_NAME: ${{ inputs.app_name }}
        SCAN_DIR: ${{ inputs.scan_directory }}
      run: |
        echo "::group::ğŸ“¦ CRIAÃ‡ÃƒO DO ARQUIVO ZIP"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ PREPARANDO ARQUIVOS PARA ANÃLISE                        â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        # Substituir caracteres especiais no nome do arquivo zip
        SAFE_APP_NAME=$(echo "${APP_NAME}" | tr '/' '_')
        echo "SAFE_APP_NAME=${SAFE_APP_NAME}" >> $GITHUB_ENV

        echo "DiretÃ³rio configurado para scan: ${SCAN_DIR}"

        # Verifica se o diretÃ³rio existe sem listar todo o conteÃºdo
        if [ ! -d "$SCAN_DIR" ]; then
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ âŒ ERRO: DIRETÃ“RIO NÃƒO ENCONTRADO                       â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::error::DiretÃ³rio '$SCAN_DIR' nÃ£o encontrado no workspace"
          echo "::error::Verifique se o diretÃ³rio existe ou use '.' para o diretÃ³rio raiz"
          echo "::endgroup::"
          exit 1
        fi

        echo "Iniciando criaÃ§Ã£o do arquivo ZIP..."

        # Criar o zip silenciosamente (-q) para reduzir a saÃ­da
        if [ "$SCAN_DIR" = "." ]; then
          # Se for diretÃ³rio raiz, exclui alguns diretÃ³rios comuns
          zip -rq "${SAFE_APP_NAME}.zip" . -x "*.git/*" "*/node_modules/*" "*.env" "*.zip"
        else
          # Se for um diretÃ³rio especÃ­fico
          zip -rq "${SAFE_APP_NAME}.zip" "$SCAN_DIR" -x "*.git/*" "*/node_modules/*" "*.env" "*.zip"
        fi

        # Verificar se o arquivo zip foi criado
        if [ ! -f "${SAFE_APP_NAME}.zip" ]; then
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ âŒ ERRO: FALHA NA CRIAÃ‡ÃƒO DO ARQUIVO ZIP                â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::error::Arquivo zip nÃ£o foi criado com sucesso"
          echo "::endgroup::"
          exit 1
        fi

        # Mostrar apenas o tamanho do arquivo zip
        ZIP_SIZE=$(du -h "${SAFE_APP_NAME}.zip" | cut -f1)
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ âœ… ARQUIVO ZIP CRIADO COM SUCESSO                       â”‚"
        echo "â”‚ ğŸ“¦ ${SAFE_APP_NAME}.zip (${ZIP_SIZE})                   â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        echo "::endgroup::"

    - name: Upload da aplicaÃ§Ã£o para o scan (SAST e/ou SCA)
      if: ${{ inputs.sast == 'true' || inputs.sca == 'true' }}
      shell: bash
      env:
        SAFE_APP_NAME: ${{ env.SAFE_APP_NAME }}
        APP_NAME: ${{ inputs.app_name }}
        APP_ID: ${{ env.APP_ID }}
        SCAN_VERSION: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}
        GET_UPLOAD_URL: ${{ env.GET_UPLOAD_URL }}
      run: |
        echo "::group::ğŸ“¤ UPLOAD DE ARQUIVOS PARA ANÃLISE"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ ENVIANDO ARQUIVOS PARA SCANNING                         â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        echo "ğŸ”– Iniciando upload com SCAN_VERSION: ${SCAN_VERSION}"

        # Verifica se o arquivo zip existe
        filePath="./${SAFE_APP_NAME}.zip"

        if [ ! -f "${filePath}" ]; then
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ âŒ ERRO: ARQUIVO ZIP NÃƒO ENCONTRADO                     â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::error::Arquivo ${filePath} nÃ£o encontrado"
          echo "::endgroup::"
          exit 1
        fi

        # Obter o tamanho do arquivo para exibir no progresso
        fileSize=$(du -h "${filePath}" | cut -f1)
        echo "ğŸ“Š Tamanho do arquivo: ${fileSize}"

        # A URL jÃ¡ deve vir pronta para uso do endpoint anterior
        echo "ğŸ”— URL de Upload: ${GET_UPLOAD_URL:0:60}..."

        # FunÃ§Ã£o para exibir barra de progresso mais visual
        show_progress() {
          local width=50
          local percent=$1
          local completed=$((width * percent / 100))
          local remaining=$((width - completed))
          local bar=$(printf "%${completed}s" | tr ' ' 'â–ˆ')
          local space=$(printf "%${remaining}s")
          printf "\rğŸ“¤ Progresso: [%s%s] %d%%" "$bar" "$space" "$percent"
        }

        # Upload com barra de progresso visÃ­vel
        echo "ğŸš€ Iniciando upload... (isso pode levar alguns minutos dependendo do tamanho do arquivo)"

        result=$(curl -# --fail --location --request PUT "${GET_UPLOAD_URL}" \
          --header 'Content-Type: application/zip' \
          --data-binary "@${filePath}" \
          2>&1 | tee /dev/stderr | grep -o '[0-9]*\.[0-9]%' | tail -1)

        exit_code=$?

        # Garantir que a barra de progresso termina em 100%
        if [ $exit_code -eq 0 ]; then
          show_progress 100
          echo -e "\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ âœ… UPLOAD CONCLUÃDO COM SUCESSO                          â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::notice title=XGuardian Scan::Upload concluÃ­do! Aguarde alguns segundos para obter o ID do scan..."
        else
          echo -e "\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ âŒ FALHA NO UPLOAD DO ARQUIVO                            â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          echo "::error title=XGuardian Scan::Falha no upload do arquivo."
          echo "::endgroup::"
          exit 1
        fi
        echo "::endgroup::"

    - name: Aguardar 30 segundos antes de buscar o ID do scan
      shell: bash
      if: ${{ inputs.get_scan_id == 'true' }}
      run: |
        echo "Aguardando 30 segundos"
        for i in {1..3}; do
          sleep 10
          echo "10 segundos concluÃ­dos ($i de 3)"
        done

    - name: Obter ID(s) do(s) scan(s) (SAST e/ou SCA ou DAST)
      shell: bash
      if: ${{ inputs.get_scan_id == 'true' }}
      env:
        BASE_URL: ${{ env.BASE_URL }}
        REPORTER_URL: ${{ env.REPORTER_URL }}
        APP_ID: ${{ env.APP_ID }}
        API_TOKEN: ${{ env.API_TOKEN }}
        SCAN_VERSION: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}
        APP_NAME: ${{ inputs.app_name }}
        DEBUG_LEVEL: ${{ inputs.debug_level || 'normal' }}
      run: |
        echo "::group::ğŸ” BUSCANDO ID DO SCAN"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ BUSCANDO ID DO SCAN                                     â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        # FunÃ§Ã£o para log condicional baseado no nÃ­vel de debug
        debug_log() {
          local level="$1"
          local message="$2"
          
          case "$DEBUG_LEVEL" in
            verbose)
              # No modo verbose, mostra tudo
              echo "$message"
              ;;
            normal)
              # No modo normal, mostra apenas nÃ­veis info e acima
              if [[ "$level" != "trace" ]]; then
                echo "$message"
              fi
              ;;
            minimal)
              # No modo minimal, mostra apenas warnings e erros
              if [[ "$level" == "warn" || "$level" == "error" ]]; then
                echo "$message"
              fi
              ;;
          esac
        }

        echo "ğŸ” Iniciando busca pelo ID do scan com versÃ£o: ${SCAN_VERSION}"
        debug_log "info" "ğŸ“‹ AplicaÃ§Ã£o: ${APP_NAME} (ID: ${APP_ID})"

        # Verificar se jÃ¡ temos o scan_id definido em uma execuÃ§Ã£o anterior
        if [ -f "/tmp/xguardian_scan_complete" ] && [ -s "/tmp/xguardian_scan_complete" ]; then
          echo "ğŸ”„ Arquivo de estado do scan encontrado. Verificando dados..."
          IFS=':' read -r stored_app_id stored_scan_id < /tmp/xguardian_scan_complete
          
          if [ -n "$stored_app_id" ] && [ -n "$stored_scan_id" ]; then
            echo "âœ… Usando ID de scan previamente encontrado: $stored_scan_id"
            echo "APP_ID=${stored_app_id}" >> $GITHUB_ENV
            echo "SCAN_ID=${stored_scan_id}" >> $GITHUB_ENV
            echo "SCAN_URL=${BASE_URL}/aplicacoes/${stored_app_id}/scans" >> $GITHUB_ENV
            echo "::endgroup::"
            exit 0
          fi
        fi

        # URL da API (apenas primeira pÃ¡gina)
        API_URL="${REPORTER_URL}/get_scan_pagination/${APP_ID}?page=1&items_per_page=10"
        echo "ğŸŒ URL da API: ${API_URL}"

        # Tenta obter o scan ID por atÃ© 5 minutos (30 tentativas, 10 segundos cada)
        echo "â³ Iniciando pesquisa pelo scan criado (atÃ© 5 minutos)..."
        for i in {1..30}; do
          echo "ğŸ”„ Tentativa $i de 30..."
          
          # Captura a resposta completa
          RESPONSE=$(curl -sS -X GET "${API_URL}" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")
          
          # Verifica se a resposta Ã© um JSON vÃ¡lido
          if ! echo "$RESPONSE" | jq . >/dev/null 2>&1; then
            echo "âš ï¸ Resposta nÃ£o Ã© um JSON vÃ¡lido:"
            echo "$RESPONSE"
            if [ $i -lt 30 ]; then
              echo "â±ï¸ Aguardando prÃ³xima tentativa..."
              sleep 10
              continue
            fi
            echo "::error::âŒ API retornou resposta invÃ¡lida apÃ³s mÃºltiplas tentativas."
            echo "::endgroup::"
            exit 1
          fi

          # Debug da resposta (limitado aos campos relevantes)
          echo "ğŸ“‹ Scans encontrados:"
          SCANS_INFO=$(echo "$RESPONSE" | jq -r '.data[] | "ID: \(.id) | VersÃ£o: \(.scanuuid) | Status: \(.scan_status) | Data: \(.created_at)"')
          if [ -z "$SCANS_INFO" ]; then
            echo "ğŸ“­ Nenhum scan encontrado para esta aplicaÃ§Ã£o."
          else
            echo "$SCANS_INFO"
          fi
          
          # Verifica se a resposta tem a estrutura esperada e contÃ©m dados
          if [ "$(echo "$RESPONSE" | jq -r 'has("data")')" = "true" ] && [ "$(echo "$RESPONSE" | jq -r '.data | length')" -gt 0 ]; then
            # Busca o scan com o SCAN_VERSION especÃ­fico
            SCAN_DATA=$(echo "$RESPONSE" | jq -r --arg version "$SCAN_VERSION" '.data[] | select(.scanuuid == $version)')
            
            if [ -n "$SCAN_DATA" ] && [ "$SCAN_DATA" != "null" ]; then
              SCAN_ID=$(echo "$SCAN_DATA" | jq -r '.id')
              SCAN_STATUS=$(echo "$SCAN_DATA" | jq -r '.scan_status')
              CREATED_AT=$(echo "$SCAN_DATA" | jq -r '.created_at')
              
              # Define as variÃ¡veis no ambiente
              {
                echo "APP_ID=${APP_ID}"
                echo "SCAN_ID=${SCAN_ID}"
                echo "SCAN_URL=${BASE_URL}/aplicacoes/${APP_ID}/scans"
              } >> "$GITHUB_ENV"
              
              # Cria arquivo de estado com os dados
              echo "${APP_ID}:${SCAN_ID}" > /tmp/xguardian_scan_complete
              
              echo "âœ… Scan encontrado com sucesso!"
              echo "::notice title=XGuardian Scan::Scan encontrado com sucesso!"
              echo "::notice title=XGuardian Scan::AplicaÃ§Ã£o: ${APP_NAME}"
              echo "::notice title=XGuardian Scan::ID da AplicaÃ§Ã£o (APP_ID): ${APP_ID}"
              echo "::notice title=XGuardian Scan::ID do Scan (SCAN_ID): ${SCAN_ID}"
              echo "::notice title=XGuardian Scan::Status: ${SCAN_STATUS}"
              echo "::notice title=XGuardian Scan::Criado em: ${CREATED_AT}"
              break
            else
              echo "ğŸ” Scan com versÃ£o '${SCAN_VERSION}' ainda nÃ£o encontrado nesta tentativa."
            fi
          else
            echo "âš ï¸ Resposta da API nÃ£o contÃ©m dados vÃ¡lidos de scans."
          fi
          
          if [ $i -lt 30 ]; then
            echo "â±ï¸ Scan ainda nÃ£o encontrado. Aguardando 10 segundos..."
            sleep 10
          fi
        done

        # Verifica se o SCAN_ID foi encontrado
        if [ -z "${SCAN_ID:-}" ] || [ "${SCAN_ID:-null}" == "null" ]; then
          echo "::error title=XGuardian Scan::âŒ NÃ£o foi possÃ­vel encontrar o ID do Scan apÃ³s mÃºltiplas tentativas."
          echo "::error title=XGuardian Scan::VersÃ£o procurada: ${SCAN_VERSION}"
          echo "::error title=XGuardian Scan::Ãšltima resposta da API:"
          echo "$RESPONSE" | jq '.' || echo "$RESPONSE"
          echo "::endgroup::"
          exit 1
        fi
        echo "::endgroup::"

    - name: Aguardar finalizaÃ§Ã£o do scan
      shell: bash
      env:
        REPORTER_URL: ${{ env.REPORTER_URL }}
        API_TOKEN: ${{ env.API_TOKEN }}
        APP_ID: ${{ env.APP_ID }}
        SCAN_VERSION: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}
      run: |
        echo "::group::â³ Monitorando status do scan"
        SCAN_STATUS=""
        start_time=$(date +%s)

        echo "ğŸ”„ Aguardando finalizaÃ§Ã£o do scan (versÃ£o: ${SCAN_VERSION})"
        echo "   Este processo pode levar alguns minutos..."
        echo "   A ferramenta verificarÃ¡ o status periodicamente."
        echo ""

        check_scan_status() {
          local response=$(curl -s -X GET "${REPORTER_URL}/get_scan_pagination/${APP_ID}?page=1&items_per_page=10" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")

          if ! echo "$response" | jq . >/dev/null 2>&1; then
            echo "âš ï¸ Resposta nÃ£o Ã© um JSON vÃ¡lido."
            return 1
          fi

          SCAN_DATA=$(echo "$response" | jq -r --arg version "${SCAN_VERSION}" '.data[] | select(.scanuuid == $version)')

          if [ -n "$SCAN_DATA" ] && [ "$SCAN_DATA" != "null" ]; then
            SCAN_STATUS=$(echo "$SCAN_DATA" | jq -r '.scan_status')
            return 0
          else
            echo "âš ï¸ Scan nÃ£o encontrado na resposta."
            return 1
          fi
        }

        # Visual para acompanhamento do progresso
        display_progress() {
          local elapsed=$1
          local status=$2
          local elapsed_min=$((elapsed / 60))
          local elapsed_sec=$((elapsed % 60))
          
          if [ "$status" == "RUNNING" ]; then
            status_emoji="ğŸ”„"
            status_text="EM EXECUÃ‡ÃƒO"
          elif [ "$status" == "FINISHED" ]; then
            status_emoji="âœ…"
            status_text="FINALIZADO"
          elif [ "$status" == "PENDING" ]; then
            status_emoji="â³"
            status_text="PENDENTE"
          elif [ "$status" == "FAILED" ]; then
            status_emoji="âŒ"
            status_text="FALHOU"
          else
            status_emoji="â“"
            status_text="DESCONHECIDO"
          fi
          
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ Status do Scan: ${status_emoji} ${status_text}"
          echo "â”‚ Tempo decorrido: ${elapsed_min}m ${elapsed_sec}s"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        }

        # Loop principal para monitorar o status
        for i in {1..30}; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          
          echo "ğŸ” Verificando status (tentativa $i de 30)..."
          
          if check_scan_status; then
            display_progress $elapsed "$SCAN_STATUS"
            
            if [ "$SCAN_STATUS" == "FINISHED" ]; then
              echo "âœ… Scan finalizado com sucesso!"
              echo "::notice title=XGuardian Scan::Scan finalizado com sucesso!"
              break
            elif [ "$SCAN_STATUS" == "RUNNING" ] || [ "$SCAN_STATUS" == "PENDING" ]; then
              echo "â³ Scan ainda em andamento. Aguardando 2 minutos antes da prÃ³xima verificaÃ§Ã£o..."
              sleep 120
            elif [ "$SCAN_STATUS" == "FAILED" ]; then
              echo "::error::âŒ Scan falhou durante a execuÃ§Ã£o."
              echo "::endgroup::"
              exit 1
            else
              echo "âš ï¸ Status inesperado do scan: $SCAN_STATUS"
              echo "::endgroup::"
              exit 1
            fi
          else
            echo "âš ï¸ Erro ao verificar status do scan. Tentando novamente em 2 minutos..."
            sleep 120
          fi
        done

        if [ "$SCAN_STATUS" != "FINISHED" ]; then
          echo "::error::âŒ Scan nÃ£o foi finalizado apÃ³s mÃºltiplas verificaÃ§Ãµes (timeout)."
          echo "::endgroup::"
          exit 1
        fi

        # Mostrar tempo total de execuÃ§Ã£o
        end_time=$(date +%s)
        total_elapsed=$((end_time - start_time))
        total_min=$((total_elapsed / 60))
        total_sec=$((total_elapsed % 60))
        echo "â±ï¸ Tempo total de execuÃ§Ã£o do scan: ${total_min}m ${total_sec}s"
        echo "::endgroup::"

    - name: Buscar vulnerabilidades e comparar com polÃ­ticas
      shell: bash
      env:
        REPORTER_URL: ${{ env.REPORTER_URL }}
        API_TOKEN: ${{ env.API_TOKEN }}
        APP_ID: ${{ env.APP_ID }}
        SCAN_VERSION: ${{ format('{0}-{1}', inputs.app_name, steps.vars.outputs.short_sha) }}
        SAST_CRITICAL: ${{ env.SAST_CRITICAL }}
        SAST_HIGH: ${{ env.SAST_HIGH }}
        SAST_MEDIUM: ${{ env.SAST_MEDIUM }}
        SAST_LOW: ${{ env.SAST_LOW }}
        SAST_RATING: ${{ env.SAST_RATING }}
        SCA_CRITICAL: ${{ env.SCA_CRITICAL }}
        SCA_HIGH: ${{ env.SCA_HIGH }}
        SCA_MEDIUM: ${{ env.SCA_MEDIUM }}
        SCA_LOW: ${{ env.SCA_LOW }}
        SCA_RATING: ${{ env.SCA_RATING }}
        DAST_CRITICAL: ${{ env.DAST_CRITICAL }}
        DAST_HIGH: ${{ env.DAST_HIGH }}
        DAST_MEDIUM: ${{ env.DAST_MEDIUM }}
        DAST_LOW: ${{ env.DAST_LOW }}
        DAST_RATING: ${{ env.DAST_RATING }}
        SAST_PIPEACTION: ${{ env.SAST_PIPEACTION }}
        SCA_PIPEACTION: ${{ env.SCA_PIPEACTION }}
        DAST_PIPEACTION: ${{ env.DAST_PIPEACTION }}
        POLICY_SAST: ${{ env.POLICY_SAST }}
        POLICY_SCA: ${{ env.POLICY_SCA }}
        POLICY_DAST: ${{ env.POLICY_DAST }}
        BASE_URL: ${{ env.BASE_URL }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        echo "::group::AvaliaÃ§Ã£o de vulnerabilidades"
        check_scan_status() {
          local response=$(curl -s -X GET "${REPORTER_URL}/get_scan_pagination/${APP_ID}?page=1&items_per_page=10" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")

          if ! echo "$response" | jq . >/dev/null 2>&1; then
            echo "Debug: Resposta nÃ£o Ã© um JSON vÃ¡lido:"
            echo "$response"
            return 1
          fi

          SCAN_STATUS=$(echo "$response" | jq -r --arg version "${SCAN_VERSION}" '.data[] | select(.scanuuid == $version) | .scan_status')

          if [ -z "$SCAN_STATUS" ] || [ "$SCAN_STATUS" == "null" ]; then
            echo "::error::NÃ£o foi possÃ­vel obter o status do scan."
            return 1
          fi

          echo "Status do scan: $SCAN_STATUS"
        }

        fetch_vulnerabilities() {
          local response=$(curl -s -X GET "${REPORTER_URL}/get_scan_pagination/${APP_ID}?page=1&items_per_page=10" \
            -H 'accept: application/json' \
            -H "Authorization: Bearer ${API_TOKEN}")

          if ! echo "$response" | jq . >/dev/null 2>&1; then
            echo "Debug: Resposta nÃ£o Ã© um JSON vÃ¡lido:"
            echo "$response"
            exit 1
          fi

          local scan_data=$(echo "$response" | jq -r --arg version "${SCAN_VERSION}" '.data[] | select(.scanuuid == $version)')

          if [ -n "$scan_data" ] && [ "$scan_data" != "null" ]; then
            echo "Scan encontrado com sucesso!"
            
            # Extrair informaÃ§Ãµes bÃ¡sicas do scan
            local scan_id=$(echo "$scan_data" | jq -r '.id')
            local scan_date=$(echo "$scan_data" | jq -r '.created_at')
            
            echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
            echo "â”‚ InformaÃ§Ãµes do Scan                                     â”‚"
            echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
            echo "â”‚ AplicaÃ§Ã£o: ${APP_NAME}"
            echo "â”‚ ID do Scan: $scan_id"
            echo "â”‚ Data do Scan: $scan_date"
            echo "â”‚ Status: $SCAN_STATUS"
            echo "â”‚"
            echo "â”‚ ğŸ”— Resultados completos disponÃ­veis em:"
            echo "â”‚ ${BASE_URL}/aplicacoes/${APP_ID}/scans"
            echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          else
            echo "::error::Scan nÃ£o encontrado na resposta."
            exit 1
          fi

          compare_vulnerabilities "$scan_data"
        }

        compare_vulnerabilities() {
          local scan_data=$1
          local has_issues=false

          local sast_critical=$(echo "$scan_data" | jq -r '.scan_critical // 0')
          local sast_high=$(echo "$scan_data" | jq -r '.scan_high // 0')
          local sast_medium=$(echo "$scan_data" | jq -r '.scan_medium // 0')
          local sast_low=$(echo "$scan_data" | jq -r '.scan_low // 0')

          local sca_critical=$(echo "$scan_data" | jq -r '.sca_critical // 0')
          local sca_high=$(echo "$scan_data" | jq -r '.sca_high // 0')
          local sca_medium=$(echo "$scan_data" | jq -r '.sca_medium // 0')
          local sca_low=$(echo "$scan_data" | jq -r '.sca_low // 0')

          local dast_critical=$(echo "$scan_data" | jq -r '.dast_critical // 0')
          local dast_high=$(echo "$scan_data" | jq -r '.dast_high // 0')
          local dast_medium=$(echo "$scan_data" | jq -r '.dast_medium // 0')
          local dast_low=$(echo "$scan_data" | jq -r '.dast_low // 0')

          # Garantir que valores estÃ£o definidos
          SAST_CRITICAL=${SAST_CRITICAL:-0}
          SAST_HIGH=${SAST_HIGH:-0}
          SAST_MEDIUM=${SAST_MEDIUM:-0}
          SAST_LOW=${SAST_LOW:-0}

          SCA_CRITICAL=${SCA_CRITICAL:-0}
          SCA_HIGH=${SCA_HIGH:-0}
          SCA_MEDIUM=${SCA_MEDIUM:-0}
          SCA_LOW=${SCA_LOW:-0}

          DAST_CRITICAL=${DAST_CRITICAL:-0}
          DAST_HIGH=${DAST_HIGH:-0}
          DAST_MEDIUM=${DAST_MEDIUM:-0}
          DAST_LOW=${DAST_LOW:-0}

          check_vulnerabilities() {
            local scan_type=$1
            local critical=$2
            local high=$3
            local medium=$4
            local low=$5
            local policy_critical=$6
            local policy_high=$7
            local policy_medium=$8
            local policy_low=$9
            local pipeaction=${10}
            local policy_id=${11}
            local result="passed"
            local local_has_issues=false

            if [ -z "$policy_critical" ] || [ -z "$policy_high" ] || [ -z "$policy_medium" ] || [ -z "$policy_low" ]; then
              return
            fi

            if [ "$policy_critical" -eq 0 ] && [ "$policy_high" -eq 0 ] && [ "$policy_medium" -eq 0 ] && [ "$policy_low" -eq 0 ]; then
              return
            fi

            echo "::group::Resultados de vulnerabilidades para ${scan_type^^}"
            
            # CabeÃ§alho da tabela
            echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
            echo "â”‚ AnÃ¡lise de vulnerabilidades de ${scan_type^^}           â”‚"
            echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
            echo "â”‚ PolÃ­tica aplicada: ID $policy_id                        â”‚"
            echo "â”‚ Limites definidos:                                      â”‚"
            echo "â”‚   CRÃTICO: $policy_critical | ALTO: $policy_high | MÃ‰DIO: $policy_medium | BAIXO: $policy_low â”‚"
            echo "â”‚ AÃ§Ã£o configurada: $pipeaction                           â”‚"
            echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
            echo "â”‚ Vulnerabilidades encontradas:                           â”‚"

            # Mostrar vulnerabilidades encontradas com formataÃ§Ã£o adequada
            if [ "$critical" -gt 0 ] || [ "$high" -gt 0 ] || [ "$medium" -gt 0 ] || [ "$low" -gt 0 ]; then
                [ "$critical" -gt 0 ] && echo "â”‚ ğŸ”´ CRÃTICO: $critical"
                [ "$high" -gt 0 ] && echo "â”‚ ğŸŸ  ALTO: $high"
                [ "$medium" -gt 0 ] && echo "â”‚ ğŸŸ¡ MÃ‰DIO: $medium"
                [ "$low" -gt 0 ] && echo "â”‚ ğŸ”µ BAIXO: $low"
            else
                echo "â”‚ âœ… Nenhuma vulnerabilidade encontrada!"
            fi
            echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

            # Verificar se excede a polÃ­tica
            if [ "$critical" -gt "$policy_critical" ] || [ "$high" -gt "$policy_high" ] || [ "$medium" -gt "$policy_medium" ] || [ "$low" -gt "$policy_low" ]; then
                local_has_issues=true
                result="failed"
                
                if [ "$pipeaction" == "fail" ]; then
                    echo "::error title=Falha de seguranÃ§a no tipo ${scan_type^^}::Vulnerabilidades ${scan_type^^} excedem as polÃ­ticas definidas (ID: $policy_id)."
                elif [ "$pipeaction" == "warn" ]; then
                    echo "::warning title=Alerta de seguranÃ§a no tipo ${scan_type^^}::Vulnerabilidades ${scan_type^^} excedem as polÃ­ticas definidas (ID: $policy_id)."
                else
                    echo "::notice title=InformaÃ§Ã£o de seguranÃ§a no tipo ${scan_type^^}::Vulnerabilidades ${scan_type^^} excedem as polÃ­ticas definidas (ID: $policy_id), mas nenhuma aÃ§Ã£o foi tomada devido ao pipeaction definido como 'noAction'."
                fi
            else
                echo "::notice title=VerificaÃ§Ã£o de ${scan_type^^} concluÃ­da::Vulnerabilidades ${scan_type^^} estÃ£o dentro dos limites aceitÃ¡veis definidos na polÃ­tica (ID: $policy_id)."
            fi
            
            # Resumo do resultado
            if [ "$local_has_issues" = true ]; then
                echo "âŒ Resultado da anÃ¡lise ${scan_type^^}: FALHOU"
                has_issues=true
            else
                echo "âœ… Resultado da anÃ¡lise ${scan_type^^}: PASSOU"
            fi
            
            echo "::endgroup::"
            
            return 0
          }

          # Verificar cada tipo de scan
          [ "$sast_critical" -gt 0 ] || [ "$sast_high" -gt 0 ] || [ "$sast_medium" -gt 0 ] || [ "$sast_low" -gt 0 ] && \
          check_vulnerabilities "sast" "$sast_critical" "$sast_high" "$sast_medium" "$sast_low" "$SAST_CRITICAL" "$SAST_HIGH" "$SAST_MEDIUM" "$SAST_LOW" "$SAST_PIPEACTION" "$POLICY_SAST"
          
          [ "$sca_critical" -gt 0 ] || [ "$sca_high" -gt 0 ] || [ "$sca_medium" -gt 0 ] || [ "$sca_low" -gt 0 ] && \
          check_vulnerabilities "sca" "$sca_critical" "$sca_high" "$sca_medium" "$sca_low" "$SCA_CRITICAL" "$SCA_HIGH" "$SCA_MEDIUM" "$SCA_LOW" "$SCA_PIPEACTION" "$POLICY_SCA"
          
          [ "$dast_critical" -gt 0 ] || [ "$dast_high" -gt 0 ] || [ "$dast_medium" -gt 0 ] || [ "$dast_low" -gt 0 ] && \
          check_vulnerabilities "dast" "$dast_critical" "$dast_high" "$dast_medium" "$dast_low" "$DAST_CRITICAL" "$DAST_HIGH" "$DAST_MEDIUM" "$DAST_LOW" "$DAST_PIPEACTION" "$POLICY_DAST"
          
          echo "::group::Resultado final da anÃ¡lise"
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "â”‚ ğŸ“Š RESUMO DA ANÃLISE DE SEGURANÃ‡A XGUARDIAN             â”‚"
          echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
          if [ "$has_issues" = true ]; then
            echo "â”‚ âŒ STATUS: VULNERABILIDADES ACIMA DO LIMITE PERMITIDO    â”‚"
          else
            echo "â”‚ âœ… STATUS: TODAS VULNERABILIDADES DENTRO DO ACEITÃVEL    â”‚"
          fi
          echo "â”‚                                                         â”‚"
          echo "â”‚ ğŸ“ˆ TOTAL POR CATEGORIA:                                 â”‚"
          echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
          
          # SAST
          if [ "$sast_critical" -gt 0 ] || [ "$sast_high" -gt 0 ] || [ "$sast_medium" -gt 0 ] || [ "$sast_low" -gt 0 ]; then
            echo "â”‚ SAST (AnÃ¡lise de CÃ³digo Fonte):                         â”‚"
            echo "â”‚  ğŸ”´ CRÃTICO:  $sast_critical"
            echo "â”‚  ğŸŸ  ALTO:     $sast_high"
            echo "â”‚  ğŸŸ¡ MÃ‰DIO:    $sast_medium"
            echo "â”‚  ğŸ”µ BAIXO:    $sast_low"
            echo "â”‚                                                         â”‚"
          fi
          
          # SCA
          if [ "$sca_critical" -gt 0 ] || [ "$sca_high" -gt 0 ] || [ "$sca_medium" -gt 0 ] || [ "$sca_low" -gt 0 ]; then
            echo "â”‚ SCA (AnÃ¡lise de DependÃªncias):                          â”‚"
            echo "â”‚  ğŸ”´ CRÃTICO:  $sca_critical"
            echo "â”‚  ğŸŸ  ALTO:     $sca_high"
            echo "â”‚  ğŸŸ¡ MÃ‰DIO:    $sca_medium"
            echo "â”‚  ğŸ”µ BAIXO:    $sca_low"
            echo "â”‚                                                         â”‚"
          fi
          
          # DAST
          if [ "$dast_critical" -gt 0 ] || [ "$dast_high" -gt 0 ] || [ "$dast_medium" -gt 0 ] || [ "$dast_low" -gt 0 ]; then
            echo "â”‚ DAST (Testes DinÃ¢micos):                                â”‚"
            echo "â”‚  ğŸ”´ CRÃTICO:  $dast_critical"
            echo "â”‚  ğŸŸ  ALTO:     $dast_high"
            echo "â”‚  ğŸŸ¡ MÃ‰DIO:    $dast_medium"
            echo "â”‚  ğŸ”µ BAIXO:    $dast_low"
            echo "â”‚                                                         â”‚"
          fi
          
          echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
          echo "â”‚ ğŸ”— RESULTADOS COMPLETOS DISPONÃVEIS EM:                 â”‚"
          echo "â”‚ ${BASE_URL}/aplicacoes/${APP_ID}/scans                  â”‚"
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
          
          # Adicionar tempo total de execuÃ§Ã£o
          if [ -f "/tmp/xguardian_start_time" ]; then
            start_time=$(cat /tmp/xguardian_start_time)
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            elapsed_min=$((elapsed / 60))
            elapsed_sec=$((elapsed % 60))
            echo "â±ï¸ Tempo total de execuÃ§Ã£o: ${elapsed_min}m ${elapsed_sec}s"
          fi
          echo "::endgroup::"
        }

        while true; do
          check_scan_status
          if [ "$SCAN_STATUS" == "FINISHED" ]; then
            echo "Scan finalizado. Aguardando 30 segundos antes de buscar vulnerabilidades..."
            sleep 30
            fetch_vulnerabilities
            break
          else
            echo "Scan ainda nÃ£o finalizado. Aguardando 30 segundos antes de verificar novamente..."
            sleep 30
          fi
        done
        echo "::endgroup::"

    - name: Finalizar e validar outputs
      id: final_outputs
      shell: bash
      env:
        BASE_URL: ${{ env.BASE_URL }}
      if: ${{ inputs.get_scan_id == 'true' }}
      run: |
        if [ ! -f "/tmp/xguardian_scan_complete" ] || [ ! -s "/tmp/xguardian_scan_complete" ]; then
          echo "::error title=XGuardian Scan::Arquivo de estado nÃ£o encontrado ou vazio"
          exit 1
        fi

        # LÃª os valores do arquivo de estado
        IFS=':' read -r app_id scan_id < /tmp/xguardian_scan_complete

        # Valida os valores
        if [ -z "$app_id" ] || [ -z "$scan_id" ]; then
          echo "::error title=XGuardian Scan::Dados invÃ¡lidos no arquivo de estado"
          exit 1
        fi

        # Define os outputs corretamente
        echo "app_id=$app_id" >> "$GITHUB_OUTPUT"
        echo "scan_id=$scan_id" >> "$GITHUB_OUTPUT"
        echo "scan_url=${BASE_URL}/aplicacoes/$app_id/scans" >> "$GITHUB_OUTPUT"

        # Define tambÃ©m no ambiente para compatibilidade
        {
          echo "APP_ID=$app_id"
          echo "SCAN_ID=$scan_id"
          echo "SCAN_URL=${BASE_URL}/aplicacoes/$app_id/scans"
        } >> "$GITHUB_ENV"

        # Log para debug
        echo "Debug: Outputs definidos"
        echo "app_id: $app_id"
        echo "scan_id: $scan_id"
        echo "scan_url: ${BASE_URL}/aplicacoes/$app_id/scans"

    - name: Salvar vulnerabilidades no banco de dados
      if: ${{ inputs.save_vulns == 'true' }}
      shell: bash
      env:
        UPLOADER_URL: ${{ env.UPLOADER_URL }}
        APP_ID: ${{ env.APP_ID }}
        API_TOKEN: ${{ env.API_TOKEN }}
      run: |
        PATCH_URL="${UPLOADER_URL}/accept_save_vulns"
        DATA=$(cat << EOF
        {
          "app_id": ${APP_ID},
          "accept_export": true
        }
        EOF
        )

        # Captura tanto o status HTTP quanto o corpo da resposta
        RESPONSE=$(curl -sS -X PATCH "${PATCH_URL}" \
          -H 'accept: application/json' \
          -H 'Content-Type: application/json' \
          -H "Authorization: Bearer ${API_TOKEN}" \
          -d "${DATA}" \
          -w "\n%{http_code}")

        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

        echo "Status HTTP: $HTTP_STATUS"
        echo "Resposta: $RESPONSE_BODY"

        if [ "$HTTP_STATUS" -eq 200 ]; then
          echo "Vulnerabilidades salvas com sucesso no banco de dados."
        else
          echo "Erro ao salvar vulnerabilidades. Status: $HTTP_STATUS"
          echo "Detalhes: $RESPONSE_BODY"
          exit 1
        fi

    - name: Resumo da execuÃ§Ã£o
      shell: bash
      if: always()
      env:
        APP_ID: ${{ env.APP_ID }}
        SCAN_ID: ${{ env.SCAN_ID }}
        SCAN_URL: ${{ env.SCAN_URL }}
        APP_NAME: ${{ inputs.app_name }}
        SAST: ${{ inputs.sast }}
        SCA: ${{ inputs.sca }}
        DAST: ${{ inputs.dast }}
        BASE_URL: ${{ env.BASE_URL }}
      run: |
        echo "::group::ğŸ“Š RESUMO DA EXECUÃ‡ÃƒO"
        echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo "â”‚ RESUMO DO SCAN DE SEGURANÃ‡A XGUARDIAN                   â”‚"
        echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"

        # Verificar se o arquivo com o tempo de inÃ­cio existe
        if [ -f "/tmp/xguardian_start_time" ]; then
          start_time=$(cat /tmp/xguardian_start_time)
          end_time=$(date +%s)
          total_elapsed=$((end_time - start_time))
          total_min=$((total_elapsed / 60))
          total_sec=$((total_elapsed % 60))
          
          echo "â±ï¸ Tempo total de execuÃ§Ã£o: ${total_min}m ${total_sec}s"
        fi

        echo ""
        echo "ğŸ” AplicaÃ§Ã£o: ${APP_NAME}"
        echo "ğŸ†” ID da AplicaÃ§Ã£o: ${APP_ID:-'NÃ£o disponÃ­vel'}"
        echo "ğŸ”¢ ID do Scan: ${SCAN_ID:-'NÃ£o disponÃ­vel'}"

        # Gerar um "checkmark" para cada tipo de scan habilitado
        echo ""
        echo "ğŸ“‹ Tipos de scan executados:"
        [ "${SAST}" == "true" ] && echo "  âœ… SAST (Source Code Analysis)"
        [ "${SCA}" == "true" ] && echo "  âœ… SCA (Software Composition Analysis)"
        [ "${DAST}" == "true" ] && echo "  âœ… DAST (Dynamic Application Security Testing)"

        # Mostrar o link para os resultados se disponÃ­vel
        if [ -n "${SCAN_URL}" ]; then
          echo ""
          echo "ğŸ”— Resultados completos disponÃ­veis em:"
          echo "  ${SCAN_URL}"
        else
          echo ""
          echo "âš ï¸ Link para resultados nÃ£o disponÃ­vel"
        fi

        echo ""
        echo "âœ… Processo de scan concluÃ­do"
        echo "::endgroup::"
